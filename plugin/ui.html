<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vibe Gradients</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/thomas-lowry/figma-plugin-ds/dist/figma-plugin-ds.css"
    />
    <style>
      :root { color-scheme: light; }
      body {
        margin: 0;
        background: #f6f6f7;
        overflow: hidden;
      }
      .wrap {
        display: flex;
        flex-direction: column;
        gap: 0;
        padding: 0 12px 12px;
        height: 100vh;
        overflow: hidden;
      }
      .tabs {
        position: sticky;
        top: 0;
        z-index: 2;
        display: flex;
        gap: 16px;
        background: #fff;
        padding: 8px 12px;
        margin: 0 -12px 12px -12px;
        border-bottom: 1px solid rgba(0,0,0,0.08);
      }
      .tab {
        padding: 6px 0;
        font-size: 12px;
        border: none;
        border-radius: 0;
        background: transparent;
        color: #666;
        cursor: pointer;
      }
      .tab.active {
        color: #111;
        font-weight: 600;
        border-bottom: 2px solid #111;
      }
      .panel {
        display: none;
        flex-direction: column;
        gap: 12px;
        padding-top: 0;
        flex: 1;
        min-height: 0;
      }
      .panel.active {
        display: flex;
      }
      .preview-frame {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 6px;
        border: none;
        overflow: hidden;
        box-sizing: border-box;
        background: #fff;
        position: relative;
      }
      .preview {
        position: absolute;
        inset: -1px;
        background: linear-gradient(180deg, #e6e6e6, #cfcfcf);
        display: block;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .row .hint {
        margin-left: 0;
      }
      .link-button {
        background: none;
        border: none;
        padding: 0;
        font-size: 12px;
        color: #555;
        cursor: pointer;
        text-decoration: underline;
      }
      .link-button.align-right {
        margin-left: auto;
      }
      .link-button:disabled {
        color: #aaa;
        cursor: default;
        text-decoration: none;
      }
      .status {
        min-height: 18px;
        font-size: 12px;
        color: #666;
      }
      .hint {
        font-size: 11px;
        color: #999;
      }
      .button {
        border-radius: 4px;
      }
      .input__field {
        border-radius: 4px;
        padding: 6px 8px;
        border: 1px solid rgba(0,0,0,0.12);
        box-shadow: none;
      }
      .input-with-action {
        position: relative;
        width: 100%;
      }
      .input-with-action .input__field {
        padding-right: 28px;
      }
      .input-action {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        border: none;
        background: transparent;
        padding: 0;
        cursor: pointer;
        color: #111;
      }
      .input-action:disabled {
        opacity: 0.5;
        cursor: default;
      }
      .input-action svg {
        display: block;
        width: 14px;
        height: 14px;
      }
      .select-wrap {
        position: relative;
        width: 100%;
      }
      .select-wrap::after {
        content: '';
        position: absolute;
        right: 8px;
        top: 50%;
        width: 20px;
        height: 20px;
        transform: translateY(-50%);
        background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'><path d='M3 5.5L7 9.5L11 5.5' fill='none' stroke='%23111' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/></svg>") no-repeat center / 14px 14px;
        pointer-events: none;
      }
      .select-wrap select.input__field {
        padding-right: 24px;
        appearance: none;
        -webkit-appearance: none;
        background: none;
      }
      .input__field:hover {
        background: inherit;
      }
      .input__field {
        height: 32px;
        padding: 6px 8px;
        font-size: 12px;
        line-height: 1.2;
      }
      select.input__field {
        padding-right: 24px;
      }
      .button {
        height: 30px;
        padding: 0 10px;
        font-size: 12px;
        line-height: 30px;
      }
      .button--primary {
        background: #000;
        border-color: #000;
        color: #fff;
      }
      .button--primary:not(:disabled):hover {
        background: #111;
        border-color: #111;
      }
      #generate:not(:disabled):hover {
        background: #111;
        border-color: #111;
      }
      .button--secondary:not(:disabled):hover {
        background: rgba(0,0,0,0.04);
        border-color: rgba(0,0,0,0.12);
      }
      .button:focus {
        outline: none;
        box-shadow: none;
      }
      .button:focus-visible {
        outline: none;
        box-shadow: none;
      }
      .button:active {
        outline: none;
        box-shadow: none;
      }
      .button:disabled {
        border-color: transparent;
        box-shadow: none;
      }
      .library {
        display: flex;
        flex-direction: column;
        gap: 8px;
        overflow-y: auto;
        padding-right: 16px;
        margin-right: -8px;
        box-sizing: border-box;
      }
      .library-empty {
        font-size: 12px;
        color: #777;
        padding: 6px 0;
      }
      .library-item {
        display: grid;
        grid-template-columns: 44px 1fr auto;
        gap: 8px;
        align-items: center;
        padding: 6px;
        border: 1px solid rgba(0,0,0,0.08);
        border-radius: 6px;
        background: #fff;
      }
      .library-preview {
        width: 44px;
        height: 44px;
        border-radius: 6px;
        border: 1px solid rgba(0,0,0,0.08);
        background: #eee;
      }
      .library-meta {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
        align-items: flex-start;
      }
      .library-title {
        font-size: 12px;
        font-weight: 600;
        color: #111;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 160px;
      }
      .library-delete {
        background: none;
        border: none;
        padding: 0;
        font-size: 12px;
        color: #555;
        cursor: pointer;
        text-decoration: underline;
      }
      @media (prefers-color-scheme: dark) {
        :root { color-scheme: dark; }
        body { background: #1b1b1b; }
        .tabs { background: #1b1b1b; border-bottom-color: rgba(255,255,255,0.1); }
        .tab { color: #aaa; }
        .tab.active { color: #fff; border-bottom-color: #fff; }
        .status { color: #aaa; }
        .hint { color: #888; }
        .preview { border-color: rgba(255,255,255,0.12); }
        .input__field {
          background: #2a2a2a;
          color: #f2f2f2;
          border-color: rgba(255,255,255,0.16);
        }
        .input-action {
          color: #f2f2f2;
        }
        .select-wrap select.input__field {
          background: #2a2a2a;
        }
        .input__field:hover,
        .input__field:focus {
          background: #2a2a2a;
          border-color: rgba(255,255,255,0.2);
          color: #f2f2f2;
        }
        .input__field::placeholder { color: #8a8a8a; }
        .select-wrap::after {
          background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'><path d='M3 5.5L7 9.5L11 5.5' fill='none' stroke='%23B0B0B0' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/></svg>") no-repeat center / 14px 14px;
        }
        .button--primary { background: #2a2a2a; border-color: rgba(255,255,255,0.16); color: #fff; }
        .button--primary:not(:disabled):hover { background: #343434; border-color: rgba(255,255,255,0.2); }
        #generate:not(:disabled):hover { background: #343434; border-color: rgba(255,255,255,0.2); }
        .button--secondary:not(:disabled):hover {
          background: rgba(255,255,255,0.08);
          border-color: rgba(255,255,255,0.2);
        }
        .button--secondary { background: #2a2a2a; border-color: rgba(255,255,255,0.16); color: #fff; }
        .link-button { color: #cfcfcf; }
        .link-button:disabled { color: #777; }
        .library-item { background: #232323; border-color: rgba(255,255,255,0.12); }
        .library-preview { border-color: rgba(255,255,255,0.12); }
        .library-title { color: #f2f2f2; }
        .library-delete { color: #cfcfcf; }
      }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="tabs">
        <button class="tab active" id="tab-generate" type="button">Generate</button>
        <button class="tab" id="tab-library" type="button">Library</button>
      </div>

      <div class="panel active" id="panel-generate">
        <div class="preview-frame">
          <div class="preview" id="preview"></div>
        </div>
        <div class="input select-wrap">
          <select id="gradient-type" class="input__field" aria-label="Gradient type">
            <option value="linear" selected>Linear</option>
            <option value="radial">Radial</option>
          </select>
        </div>
        <div class="input input-with-action">
          <input id="prompt" class="input__field" type="text" placeholder="Search a vibeâ€¦" />
          <button id="generate-inline" class="input-action" type="button" aria-label="Generate">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M5 12h14M13 6l6 6-6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
          </button>
        </div>
        <div class="row" id="action-row">
          <button id="apply" class="button button--primary" type="button" disabled>Apply</button>
          <span id="selection-hint" class="hint" style="display:none;">Select a layer to apply</span>
          <button id="save-library" class="link-button align-right" type="button" disabled>Save to library</button>
        </div>
        <div class="status" id="status"></div>
      </div>

      <div class="panel" id="panel-library">
        <div class="library" id="library-list"></div>
      </div>
    </div>

    <script>
      const API_URL = 'https://anycolorsyoulike.vercel.app/api/ollama/chat';
      const MODEL = 'gpt-oss:20b-cloud';

      const preview = document.getElementById('preview');
      const promptEl = document.getElementById('prompt');
      const generateBtn = document.getElementById('generate-inline');
      const applyBtn = document.getElementById('apply');
      const actionRow = document.getElementById('action-row');
      const saveLibraryBtn = document.getElementById('save-library');
      const statusEl = document.getElementById('status');
      const selectionHint = document.getElementById('selection-hint');
      const typeSelect = document.getElementById('gradient-type');
      const tabGenerate = document.getElementById('tab-generate');
      const tabLibrary = document.getElementById('tab-library');
      const panelGenerate = document.getElementById('panel-generate');
      const panelLibrary = document.getElementById('panel-library');
      const libraryList = document.getElementById('library-list');

      let lastStops = null;
      let lastRadialPosition = 'center';
      let currentType = 'linear';
      let lastPrompt = '';
      let cachePrompt = '';
      let cachedLinearStops = null;
      let cachedRadial = null;
      let savedGradients = [];
      let animationFrameId = null;
      let loadingFrameId = null;
      let isGenerating = false;
      let hasSelection = false;
      let hasGenerated = false;
      let hasSavedCurrent = false;
      let currentSavedId = '';

      function setStatus(text) {
        statusEl.textContent = text || '';
      }

      function updateApplyVisibility() {
        actionRow.style.display = hasGenerated ? '' : 'none';
        if (!hasSelection) {
          applyBtn.style.display = 'none';
          selectionHint.style.display = hasGenerated && !isGenerating ? '' : 'none';
        } else {
          applyBtn.style.display = '';
          selectionHint.style.display = 'none';
          if (!isGenerating) setStatus('');
        }
        saveLibraryBtn.style.display = hasGenerated ? '' : 'none';
        saveLibraryBtn.disabled = !hasGenerated || isGenerating || !lastStops;
        saveLibraryBtn.textContent = hasSavedCurrent ? 'Saved' : 'Save to library';
        parent.postMessage(
          { pluginMessage: { type: 'resize-ui', mode: hasGenerated ? 'full' : 'compact' } },
          '*'
        );
      }

      function normalizeStops(raw) {
        if (!Array.isArray(raw)) return [];
        const stops = raw.map((s) => {
          let color = String(s.color || '').trim();
          if (!color.startsWith('#')) color = '#' + color;
          if (color.length === 4) {
            color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          const stop = Math.max(0, Math.min(100, Number(s.stop) || 0));
          return { color: color.toUpperCase(), stop: Math.round(stop) };
        });
        return stops.filter((s) => /^#[0-9A-F]{6}$/i.test(s.color));
      }

      function toCssGradient(stops, type) {
        const parts = stops.map((s) => `${s.color} ${s.stop}%`);
        if (type === 'radial') {
          return `radial-gradient(circle at center, ${parts.join(', ')})`;
        }
        return `linear-gradient(180deg, ${parts.join(', ')})`;
      }

      function setActiveTab(name) {
        const isGenerate = name === 'generate';
        tabGenerate.classList.toggle('active', isGenerate);
        tabLibrary.classList.toggle('active', !isGenerate);
        panelGenerate.classList.toggle('active', isGenerate);
        panelLibrary.classList.toggle('active', !isGenerate);
      }

      function formatDate(ts) {
        if (!ts) return '';
        try {
          return new Date(ts).toLocaleDateString();
        } catch {
          return '';
        }
      }

      function renderLibrary() {
        libraryList.innerHTML = '';
        if (!savedGradients.length) {
          const empty = document.createElement('div');
          empty.className = 'library-empty';
          empty.textContent = 'No gradients saved yet.';
          libraryList.appendChild(empty);
          return;
        }
        savedGradients.forEach((item) => {
          const row = document.createElement('div');
          row.className = 'library-item';

          const previewEl = document.createElement('div');
          previewEl.className = 'library-preview';
          previewEl.style.background = toCssGradient(item.stops || [], item.type || 'linear');

          const meta = document.createElement('div');
          meta.className = 'library-meta';
          const title = document.createElement('div');
          title.className = 'library-title';
          title.textContent = item.prompt || 'Untitled';
          meta.appendChild(title);

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'library-delete';
          deleteBtn.type = 'button';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            parent.postMessage(
              { pluginMessage: { type: 'delete-gradient', id: item.id } },
              '*'
            );
          });
          meta.appendChild(deleteBtn);

          const useBtn = document.createElement('button');
          useBtn.className = 'button button--secondary';
          useBtn.type = 'button';
          useBtn.textContent = 'Use';
          useBtn.addEventListener('click', () => {
            applySavedGradient(item);
          });

          row.appendChild(previewEl);
          row.appendChild(meta);
          row.appendChild(useBtn);
          libraryList.appendChild(row);
        });
      }

      function applySavedGradient(item) {
        if (!item || !Array.isArray(item.stops) || item.stops.length < 2) return;
        const previousStops = lastStops;
        stopLoadingAnimation();
        currentType = item.type === 'radial' ? 'radial' : 'linear';
        typeSelect.value = currentType;
        lastStops = item.stops;
        lastRadialPosition = item.radialPosition || 'center';
        lastPrompt = item.prompt || '';
        promptEl.value = lastPrompt;
        cachePrompt = lastPrompt;
        cachedLinearStops = currentType === 'linear' ? item.stops : null;
        cachedRadial = currentType === 'radial' ? { stops: item.stops, position: lastRadialPosition } : null;
        hasGenerated = true;
        hasSavedCurrent = true;
        currentSavedId = item.id || '';
        animatePreviewTransition(previousStops, lastStops, currentType);
        applyBtn.disabled = !hasSelection;
        updateApplyVisibility();
        setActiveTab('generate');
      }

      // --- Color interpolation for preview animation ---
      function hexToRgb(hex) {
        const n = parseInt(hex.slice(1), 16);
        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
      }
      function rgbToHex(r, g, b) {
        return '#' + [r, g, b].map((x) => Math.round(x).toString(16).padStart(2, '0')).join('');
      }
      function lerpHex(a, b, t) {
        const ra = hexToRgb(a), rb = hexToRgb(b);
        return rgbToHex(
          ra.r + (rb.r - ra.r) * t,
          ra.g + (rb.g - ra.g) * t,
          ra.b + (rb.b - ra.b) * t
        );
      }
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }
      function sampleGradient(stops, p) {
        const sorted = [...stops].sort((a, b) => a.stop - b.stop);
        if (p <= 0) return sorted[0].color;
        if (p >= 1) return sorted[sorted.length - 1].color;
        const pos = p * 100;
        for (let i = 0; i < sorted.length - 1; i++) {
          if (pos >= sorted[i].stop && pos <= sorted[i + 1].stop) {
            const d = sorted[i + 1].stop - sorted[i].stop;
            const t = d === 0 ? 1 : (pos - sorted[i].stop) / d;
            return lerpHex(sorted[i].color, sorted[i + 1].color, t);
          }
        }
        return sorted[0].color;
      }
      function animatePreviewTransition(fromStops, toStops, type) {
        if (!fromStops || fromStops.length < 2) {
          preview.style.background = toCssGradient(toStops, type);
          return;
        }
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        const positions = Array.from(
          new Set([...fromStops.map((s) => s.stop), ...toStops.map((s) => s.stop), 0, 100])
        ).sort((a, b) => a - b);

        const startColors = positions.map((p) => sampleGradient(fromStops, p / 100));
        const endColors = positions.map((p) => sampleGradient(toStops, p / 100));
        const duration = 900;
        const state = { start: 0 };

        const tick = (now) => {
          if (!state.start) state.start = now;
          const elapsed = now - state.start;
          const t = Math.min(1, elapsed / duration);
          const eased = easeInOutCubic(t);
          const interpolated = positions.map((p, i) => ({
            stop: p,
            color: lerpHex(startColors[i], endColors[i], eased),
          }));
          preview.style.background = toCssGradient(interpolated, type);
          if (t < 1) {
            animationFrameId = requestAnimationFrame(tick);
          } else {
            animationFrameId = null;
            preview.style.background = toCssGradient(toStops, type);
          }
        };
        animationFrameId = requestAnimationFrame(tick);
      }

      function startLoadingAnimation() {
        if (loadingFrameId) cancelAnimationFrame(loadingFrameId);
        const positions = [0, 50, 100];

        const state = { start: 0 };
        const tick = (now) => {
          if (!state.start) state.start = now;
          const elapsed = now - state.start;
          const phase = (elapsed / 1000) * 12;
          if (currentType === 'radial') {
            const hue = (phase + 40) % 360;
            const stops = [
              { stop: 0, color: `hsl(${hue} 70% 60%)` },
              { stop: 70, color: `hsl(${(hue + 30) % 360} 70% 50%)` },
              { stop: 100, color: `hsl(${(hue + 60) % 360} 70% 40%)` },
            ];
            preview.style.background = `radial-gradient(circle at center, ${stops
              .map((s) => `${s.color} ${s.stop}%`)
              .join(', ')})`;
          } else {
            const stops = positions.map((p) => {
              const hue = (p * 1.4 + phase) % 360;
              return { stop: p, color: `hsl(${hue} 70% 55%)` };
            });
            preview.style.background = toCssGradient(stops, currentType);
          }
          loadingFrameId = requestAnimationFrame(tick);
        };
        loadingFrameId = requestAnimationFrame(tick);
      }

      function stopLoadingAnimation() {
        if (loadingFrameId) {
          cancelAnimationFrame(loadingFrameId);
          loadingFrameId = null;
        }
      }

      function linearSystemPrompt() {
        return `Generate a linear gradient (top to bottom) that captures the vibe of the user's input.

Return 3-6 color stops as a JSON array.
Format: [{"color":"#RRGGBB","stop":0}, {"color":"#RRGGBB","stop":30}, {"color":"#RRGGBB","stop":100}]

Rules:
- First stop must be at 0, last must be at 100
- Use uppercase hex colors only (#RRGGBB format)
- Colors should blend smoothly and naturally
- Create visual interest with contrast while maintaining harmony
- Interpret any input creatively (emotions, places, objects, vibes, nonsense - everything gets a gradient)

Return ONLY the JSON array. No explanation, no markdown.`;
      }

      function radialSystemPrompt() {
        return `Generate a radial gradient (center outward) that captures the vibe of the user's input.

Return 3-6 color stops as a JSON array, from center to edge.
Format: [{"color":"#RRGGBB","stop":0}, {"color":"#RRGGBB","stop":40}, {"color":"#RRGGBB","stop":100}]

Rules:
- First stop is the center (0), last is the outer edge (100)
- Use uppercase hex colors only (#RRGGBB format)
- Colors should blend smoothly and naturally
- Create visual interest with contrast while maintaining harmony
- Interpret any input creatively (emotions, places, objects, vibes, nonsense - everything gets a gradient)

Return ONLY the JSON array. No explanation, no markdown.`;
      }

      function parseLinearResponse(content) {
        const codeBlock = content.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlock) content = codeBlock[1].trim();
        let jsonMatch = content.match(/\[[\s\S]*\]/);
        if (!jsonMatch) {
          const trimmed = content.trim();
          if (trimmed.startsWith('[') && trimmed.endsWith(']')) jsonMatch = [trimmed];
        }
        if (!jsonMatch) throw new Error('No JSON array in response');
        let parsed;
        try {
          parsed = JSON.parse(jsonMatch[0]);
        } catch {
          throw new Error('Could not parse JSON');
        }
        const stops = normalizeStops(parsed);
        if (stops.length < 2) throw new Error('Need at least 2 color stops');
        return stops.sort((a, b) => a.stop - b.stop);
      }

      function parseRadialResponse(content) {
        const codeBlock = content.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlock) content = codeBlock[1].trim();
        let jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          const trimmed = content.trim();
          if (trimmed.startsWith('{') && trimmed.endsWith('}')) jsonMatch = [trimmed];
        }
        if (!jsonMatch) throw new Error('No JSON object in response');
        let obj;
        try {
          obj = JSON.parse(jsonMatch[0]);
        } catch {
          throw new Error('Could not parse JSON');
        }
        const centerColor = String(obj.centerColor || '').trim();
        const outerColor = String(obj.outerColor || '').trim();
        if (!centerColor || !outerColor) {
          throw new Error('Invalid radial response: missing centerColor/outerColor');
        }

        const normalizeColor = (c) => {
          let color = String(c || '').trim();
          if (!color.startsWith('#')) color = '#' + color;
          if (color.length === 4) {
            color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          return color.toUpperCase();
        };

        const softness = String(obj.softness || 'soft');
        const softnessStops = {
          'sharp': { center: 0, outer: 60 },
          'soft': { center: 0, outer: 85 },
          'ultra-soft': { center: 0, outer: 100 },
        };
        const { center: centerStop, outer: outerStop } = softnessStops[softness] || softnessStops['soft'];

        const stops = [];
        stops.push({ color: normalizeColor(centerColor), stop: centerStop });

        if (Array.isArray(obj.midColors)) {
          const mid = obj.midColors
            .map((m) => ({
              color: normalizeColor(m.color),
              position: Math.max(0, Math.min(100, Number(m.position) || 50)),
            }))
            .sort((a, b) => a.position - b.position);
          for (const m of mid) {
            const scaledPos = centerStop + (m.position / 100) * (outerStop - centerStop);
            stops.push({ color: m.color, stop: Math.round(scaledPos) });
          }
        }

        stops.push({ color: normalizeColor(outerColor), stop: outerStop });
        if (outerStop < 100) {
          stops.push({ color: normalizeColor(outerColor), stop: 100 });
        }

        return {
          stops: normalizeStops(stops).sort((a, b) => a.stop - b.stop),
          position: typeof obj.position === 'string' ? obj.position : 'center',
        };
      }

      async function generateGradient(prompt, type) {
        const systemPrompt = type === 'radial' ? radialSystemPrompt() : linearSystemPrompt();
        const userPrompt = type === 'radial'
          ? `Generate a radial gradient for: ${prompt}`
          : `Generate a gradient for: ${prompt}`;

        const res = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: MODEL,
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userPrompt },
            ],
            stream: false,
          }),
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `Request failed (${res.status})`);
        }

        const data = await res.json();
        let content = data.message?.content || data.content || '';
        if (type === 'radial') {
          return { stops: parseLinearResponse(content), position: 'center' };
        }
        return { stops: parseLinearResponse(content), position: 'center' };
      }

      function updateType(shouldGenerate) {
        currentType = typeSelect && typeSelect.value === 'radial' ? 'radial' : 'linear';
        const prompt = getEffectivePrompt();
        const hasUserPrompt = !!(promptEl.value.trim() || lastPrompt);
        const hasCached = cachePrompt === prompt && (
          (currentType === 'linear' && Array.isArray(cachedLinearStops)) ||
          (currentType === 'radial' && cachedRadial && Array.isArray(cachedRadial.stops))
        );

        if (shouldGenerate && !isGenerating && hasUserPrompt && prompt && hasCached) {
          applyCachedForType(prompt);
          return;
        }

        if (!hasGenerated && !isGenerating) {
          startLoadingAnimation();
          return;
        }

        if (lastStops && !isGenerating && !loadingFrameId) {
          preview.style.background = toCssGradient(lastStops, currentType);
        }
      }

      function setTypeDisabled(disabled) {
        if (typeSelect) {
          typeSelect.disabled = disabled;
          typeSelect.style.opacity = disabled ? '0.5' : '1';
        }
      }

      if (typeSelect) typeSelect.addEventListener('change', () => updateType(true));
      updateType(false);

      function applyGradientFromLast() {
        if (!lastStops) return;
        parent.postMessage(
          { pluginMessage: { type: 'apply-gradient', stops: lastStops, gradientType: currentType, radialPosition: lastRadialPosition } },
          '*'
        );
      }

      function getEffectivePrompt() {
        const q = promptEl.value.trim();
        if (q) return q;
        if (lastPrompt) return lastPrompt;
        return (promptEl.placeholder || '').trim();
      }

      function applyCachedForType(prompt) {
        if (cachePrompt !== prompt) return;
        const previousStops = lastStops;
        stopLoadingAnimation();
        if (currentType === 'radial' && cachedRadial && Array.isArray(cachedRadial.stops)) {
          lastStops = cachedRadial.stops;
          lastRadialPosition = cachedRadial.position || 'center';
        } else if (currentType === 'linear' && Array.isArray(cachedLinearStops)) {
          lastStops = cachedLinearStops;
        } else {
          return;
        }
        hasGenerated = true;
        hasSavedCurrent = false;
        currentSavedId = '';
        animatePreviewTransition(previousStops, lastStops, currentType);
        applyBtn.disabled = !hasSelection;
        updateApplyVisibility();
      }

      async function handleGenerate(forcedPrompt) {
        const explicitPrompt = typeof forcedPrompt === 'string' ? forcedPrompt : '';
        const q = String(explicitPrompt || getEffectivePrompt() || '').trim();
        if (!q) return;
        if (cachePrompt && cachePrompt !== q) {
          cachedLinearStops = null;
          cachedRadial = null;
        }
        cachePrompt = q;
        lastPrompt = q;
        hasSavedCurrent = false;
        currentSavedId = '';
        promptEl.blur();
        setStatus('');
        generateBtn.disabled = true;
        applyBtn.disabled = true;
        setTypeDisabled(true);
        isGenerating = true;
        updateApplyVisibility();
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        startLoadingAnimation();
        try {
          const result = await generateGradient(q, currentType);
          const previousStops = lastStops;
          lastStops = result.stops;
          hasGenerated = true;
          // Keep Figma behavior aligned with preview; ignore model position for now.
          lastRadialPosition = 'center';
          if (currentType === 'radial') {
            cachedRadial = { stops: result.stops, position: result.position || 'center' };
          } else {
            cachedLinearStops = result.stops;
          }
          stopLoadingAnimation();
          animatePreviewTransition(previousStops, result.stops, currentType);
          applyBtn.disabled = !hasSelection;
        } catch (err) {
          stopLoadingAnimation();
          setStatus(String(err.message || err));
        } finally {
          generateBtn.disabled = false;
          setTypeDisabled(false);
          isGenerating = false;
          updateApplyVisibility();
        }
      }

      generateBtn.onclick = handleGenerate;
      promptEl.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') handleGenerate();
      });

      applyBtn.onclick = () => {
        if (!lastStops) return;
        promptEl.blur();
        applyGradientFromLast();
      };

      saveLibraryBtn.onclick = () => {
        if (!lastStops || !hasGenerated || isGenerating) return;
        const prompt = getEffectivePrompt();
        if (hasSavedCurrent && currentSavedId) {
          parent.postMessage(
            { pluginMessage: { type: 'delete-gradient', id: currentSavedId } },
            '*'
          );
          hasSavedCurrent = false;
          currentSavedId = '';
          updateApplyVisibility();
          return;
        }
        const newId = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
        hasSavedCurrent = true;
        currentSavedId = newId;
        updateApplyVisibility();
        parent.postMessage(
          {
            pluginMessage: {
              type: 'save-gradient',
              gradient: {
                id: newId,
                createdAt: Date.now(),
                prompt,
                type: currentType,
                stops: lastStops,
                radialPosition: lastRadialPosition,
              },
            },
          },
          '*'
        );
      };

      window.onmessage = (event) => {
        const msg = event.data && event.data.pluginMessage;
        if (!msg || !msg.type) return;
        if (msg.type === 'selection-change') {
          hasSelection = !!msg.hasSelection;
          applyBtn.disabled = !hasSelection || !lastStops || isGenerating;
          updateApplyVisibility();
          return;
        }
        if (msg.type === 'saved-gradients') {
          savedGradients = Array.isArray(msg.gradients) ? msg.gradients : [];
          if (hasSavedCurrent && currentSavedId) {
            const stillSaved = savedGradients.some((g) => g && g.id === currentSavedId);
            if (!stillSaved) {
              hasSavedCurrent = false;
              currentSavedId = '';
              updateApplyVisibility();
            }
          }
          renderLibrary();
        }
      };

      tabGenerate.addEventListener('click', () => setActiveTab('generate'));
      tabLibrary.addEventListener('click', () => setActiveTab('library'));
      saveLibraryBtn.addEventListener('mouseenter', () => {
        if (hasSavedCurrent) saveLibraryBtn.textContent = 'Delete';
      });
      saveLibraryBtn.addEventListener('mouseleave', () => {
        saveLibraryBtn.textContent = hasSavedCurrent ? 'Saved' : 'Save to library';
      });

      promptEl.placeholder = 'Create a gradient for any vibe';
      startLoadingAnimation();
      updateApplyVisibility();
      parent.postMessage({ pluginMessage: { type: 'load-gradients' } }, '*');
    </script>
  </body>
</html>
