<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vibe Gradients</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/thomas-lowry/figma-plugin-ds/dist/figma-plugin-ds.css"
    />
    <style>
      :root { color-scheme: light; }
      body {
        margin: 0;
        background: #f6f6f7;
      }
      .wrap {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 12px;
      }
      .preview {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 0;
        background: linear-gradient(180deg, #e6e6e6, #cfcfcf);
        border: 1px solid rgba(0,0,0,0.06);
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .status {
        min-height: 18px;
        font-size: 12px;
        color: #666;
      }
      .hint {
        font-size: 11px;
        color: #999;
      }
      .button {
        border-radius: 0;
      }
      .button--primary {
        background: #000;
        border-color: #000;
        color: #fff;
      }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="preview" id="preview"></div>
      <div class="input">
        <select id="gradient-type" class="input__field" aria-label="Gradient type">
          <option value="linear" selected>Linear</option>
          <option value="radial">Radial</option>
        </select>
      </div>
      <div class="input">
        <input id="prompt" class="input__field" type="text" placeholder="Search a vibe…" />
      </div>
      <div class="row">
        <button id="generate" class="button button--primary" type="button">Generate</button>
        <button id="apply" class="button button--secondary" type="button" disabled>Apply</button>
        <span id="selection-hint" class="hint" style="display:none;">Select a layer to apply</span>
      </div>
      <div class="status" id="status"></div>
    </div>

    <script>
      const API_URL = 'https://anycolorsyoulike.vercel.app/api/ollama/chat';
      const MODEL = 'gpt-oss:20b-cloud';

      const preview = document.getElementById('preview');
      const promptEl = document.getElementById('prompt');
      const generateBtn = document.getElementById('generate');
      const applyBtn = document.getElementById('apply');
      const statusEl = document.getElementById('status');
      const selectionHint = document.getElementById('selection-hint');
      const typeSelect = document.getElementById('gradient-type');

      const DEFAULT_STOPS = [
        { color: '#0B1A0C', stop: 0 },
        { color: '#1B4B29', stop: 50 },
        { color: '#356B3A', stop: 100 },
      ];

      let lastStops = DEFAULT_STOPS;
      let lastRadialPosition = 'center';
      let currentType = 'linear';
      let animationFrameId = null;
      let loadingFrameId = null;
      let isGenerating = false;
      let hasSelection = false;
      let hasGenerated = false;

      function setStatus(text) {
        statusEl.textContent = text || '';
      }

      function updateApplyVisibility() {
        if (!hasSelection) {
          applyBtn.style.display = 'none';
          selectionHint.style.display = hasGenerated && !isGenerating ? '' : 'none';
        } else {
          applyBtn.style.display = '';
          selectionHint.style.display = 'none';
          if (!isGenerating) setStatus('');
        }
      }

      function normalizeStops(raw) {
        if (!Array.isArray(raw)) return [];
        const stops = raw.map((s) => {
          let color = String(s.color || '').trim();
          if (!color.startsWith('#')) color = '#' + color;
          if (color.length === 4) {
            color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          const stop = Math.max(0, Math.min(100, Number(s.stop) || 0));
          return { color: color.toUpperCase(), stop: Math.round(stop) };
        });
        return stops.filter((s) => /^#[0-9A-F]{6}$/i.test(s.color));
      }

      function toCssGradient(stops, type) {
        const parts = stops.map((s) => `${s.color} ${s.stop}%`);
        if (type === 'radial') {
          return `radial-gradient(circle at center, ${parts.join(', ')})`;
        }
        return `linear-gradient(180deg, ${parts.join(', ')})`;
      }

      // --- Color interpolation for preview animation ---
      function hexToRgb(hex) {
        const n = parseInt(hex.slice(1), 16);
        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
      }
      function rgbToHex(r, g, b) {
        return '#' + [r, g, b].map((x) => Math.round(x).toString(16).padStart(2, '0')).join('');
      }
      function lerpHex(a, b, t) {
        const ra = hexToRgb(a), rb = hexToRgb(b);
        return rgbToHex(
          ra.r + (rb.r - ra.r) * t,
          ra.g + (rb.g - ra.g) * t,
          ra.b + (rb.b - ra.b) * t
        );
      }
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }
      function sampleGradient(stops, p) {
        const sorted = [...stops].sort((a, b) => a.stop - b.stop);
        if (p <= 0) return sorted[0].color;
        if (p >= 1) return sorted[sorted.length - 1].color;
        const pos = p * 100;
        for (let i = 0; i < sorted.length - 1; i++) {
          if (pos >= sorted[i].stop && pos <= sorted[i + 1].stop) {
            const d = sorted[i + 1].stop - sorted[i].stop;
            const t = d === 0 ? 1 : (pos - sorted[i].stop) / d;
            return lerpHex(sorted[i].color, sorted[i + 1].color, t);
          }
        }
        return sorted[0].color;
      }
      function animatePreviewTransition(fromStops, toStops, type) {
        if (!fromStops || fromStops.length < 2) {
          preview.style.background = toCssGradient(toStops, type);
          return;
        }
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        const positions = Array.from(
          new Set([...fromStops.map((s) => s.stop), ...toStops.map((s) => s.stop), 0, 100])
        ).sort((a, b) => a - b);

        const startColors = positions.map((p) => sampleGradient(fromStops, p / 100));
        const endColors = positions.map((p) => sampleGradient(toStops, p / 100));
        const duration = 900;
        const state = { start: 0 };

        const tick = (now) => {
          if (!state.start) state.start = now;
          const elapsed = now - state.start;
          const t = Math.min(1, elapsed / duration);
          const eased = easeInOutCubic(t);
          const interpolated = positions.map((p, i) => ({
            stop: p,
            color: lerpHex(startColors[i], endColors[i], eased),
          }));
          preview.style.background = toCssGradient(interpolated, type);
          if (t < 1) {
            animationFrameId = requestAnimationFrame(tick);
          } else {
            animationFrameId = null;
            preview.style.background = toCssGradient(toStops, type);
          }
        };
        animationFrameId = requestAnimationFrame(tick);
      }

      function startLoadingAnimation() {
        if (loadingFrameId) cancelAnimationFrame(loadingFrameId);
        const baseStops = lastStops && lastStops.length >= 2
          ? lastStops
          : [{ color: '#f0f0f0', stop: 0 }, { color: '#e2e2e2', stop: 100 }];
        const positions = Array.from(
          new Set([...baseStops.map((s) => s.stop), 0, 100])
        ).sort((a, b) => a - b);

        const state = { start: 0 };
        const tick = (now) => {
          if (!state.start) state.start = now;
          const elapsed = now - state.start;
          const phase = (elapsed / 1000) * 45;
          const stops = positions.map((p) => {
            const hue = (p * 2 + phase) % 360;
            return { stop: p, color: `hsl(${hue} 80% 65%)` };
          });
          preview.style.background = toCssGradient(stops, currentType);
          loadingFrameId = requestAnimationFrame(tick);
        };
        loadingFrameId = requestAnimationFrame(tick);
      }

      function stopLoadingAnimation() {
        if (loadingFrameId) {
          cancelAnimationFrame(loadingFrameId);
          loadingFrameId = null;
        }
      }

      function linearSystemPrompt() {
        return `You generate beautiful linear gradients that capture the essence, mood, and color palette of ANY concept.

A linear gradient flows from top to bottom, like light falling, atmosphere shifting, or energy moving. Your job is to translate ANY input into a visually stunning gradient.

Output format:
[{"color": "#RRGGBB", "stop": 0}, {"color": "#RRGGBB", "stop": 100}]

Rules:
- Generate 2-4 color stops
- "stop" is position: 0 = top, 100 = bottom
- First stop must be 0, last must be 100
- Middle stops (e.g., 30, 60) create richer transitions

Interpretation guide:

EMOTIONS → Translate feeling into color flow
- Warm emotions (love, happy, hope) → warm colors flowing down, light to rich
- Dark emotions (hate, anxiety, drowning) → heavy darks at top or bottom, saturated tones
- Calm emotions → muted tones, gentle transitions, no harsh jumps

PLACES → Capture the iconic color palette and atmosphere
- Cities → their vibe (Mumbai = golden sun over ocean blue, LA = pink haze to deep purple)
- Nature locations → sky-to-ground logic (mountains = pale sky to deep forest, desert = hot white to sand orange)
- Countries → flag colors OR iconic landscape colors

NATURE/WEATHER → Think like a sky or landscape
- Time of day → sunrise/sunset warm at bottom rising to cool; night dark throughout
- Weather → storms are heavy grays/blues; snow is soft whites with cool blue shadows
- Seasons → summer is bright and warm; winter is cool and muted

OBJECTS → Extract the essential color palette
- Focus on 2-3 most recognizable colors
- Arrange them in a way that feels natural (e.g., apple = deep red to bright red to green stem hint)

AESTHETICS/VIBES → Match the era or style
- "90s" → neon cyan, magenta, high contrast stops
- "cottage core" → cream, dusty pink, sage green
- "cyber" → dark base, neon accent, teal/magenta pops
- "vaporwave" → pink, cyan, purple with distinct bands

COLORS → Create depth, not flat swatches
- "blue" → give it range (sky blue to deep navy, or navy to electric)
- Single-color requests should still have 2-3 shades for richness

ABSTRACT/POETIC → Interpret the imagery
- "jasmine in rain" → soft white to pale green to misty gray-blue
- "drowning fade" → light surface blue to deep dark ocean at bottom

NONSENSE/GREETINGS → Default to something friendly
- Warm, approachable colors
- Gentle transitions
- Nothing extreme

Design principles:
- Beautiful gradients have CONTRAST—avoid muddy middle tones
- Think about gravity: light rises, darkness pools, heat radiates
- Smooth transitions need space—don't cluster stops at 30, 35, 40
- When in doubt: 3 stops at 0, 40-50, 100

Return ONLY valid JSON array. No markdown, no explanation.
Format: [{"color":"#RRGGBB","stop":number}, ...]`;
      }

      function radialSystemPrompt() {
        return `You generate beautiful radial gradients that capture the essence, mood, and color palette of ANY concept.

A radial gradient is a glow emanating from a focal point—like light, energy, or atmosphere. Your job is to translate ANY input into a visually stunning gradient.

Output format:
{
  "centerColor": "#RRGGBB",      // focal point color
  "outerColor": "#RRGGBB",       // edge/background color
  "midColors": [{"color": "#RRGGBB", "position": 20-80}],  // optional, for richer gradients
  "position": "center" | "top-center" | "bottom-center" | "top-left" | "top-right" | "bottom-left" | "bottom-right",
  "size": "small" | "medium" | "large",
  "softness": "sharp" | "soft" | "ultra-soft",
  "shape": "circle" | "ellipse"
}

Interpretation guide:

EMOTIONS → Translate feeling into color temperature, intensity, and softness
- Warm emotions (love, happy, hope) → warm colors, soft edges, centered or rising
- Dark emotions (hate, anxiety, drowning) → deep/saturated colors, can be sharp, darker edges
- Calm emotions → muted tones, ultra-soft, gentle transitions

PLACES → Capture the iconic color palette and atmosphere, not literal geography
- Cities → their vibe (Mumbai = vibrant yellows + ocean blues, Dubai = gold + deep blue night)
- Nature locations → dominant landscape colors (Yosemite = forest green + granite gray + sky)
- Countries → can reference flag colors OR iconic landscapes

NATURE/WEATHER → Atmospheric interpretation
- Time of day → position the "light source" appropriately (sunset = bottom, morning = top-right)
- Weather → snow is soft whites, storms are dark and sharp
- Elements → fire rises (bottom-center), water pools (center or bottom)

OBJECTS → Extract the essential color palette
- Focus on 2-3 most recognizable colors
- Consider the object's texture (soft blanket = soft gradient, sharp pencil = defined stops)

AESTHETICS/VIBES → Match the era or style's color language
- "90s" → neon, cyan, magenta, high contrast
- "cottage core" → muted greens, dusty pinks, cream
- "cyber" → dark bases, neon accents, teals and magentas

COLORS → Create depth and richness, not flat swatches
- "blue" shouldn't be just blue—give it depth (deep navy center fading to bright cyan, or vice versa)
- Add subtle variations to make single-color requests interesting

ABSTRACT/POETIC → Interpret the imagery and mood
- "jasmine in rain" → soft whites, pale greens, gray-blue mist
- "drowning fade" → deep ocean blues, darkness pulling down

NONSENSE/GREETINGS → Default to something friendly and universally appealing
- Warm, approachable colors
- Soft gradients
- Nothing too extreme

QUESTIONS → Answer visually
- "What does X look like" → your best interpretation of X's color essence

Size and softness guidelines:
- "small" + "sharp": intense, focused energy (neon signs, spotlights, concentrated emotions like anxiety)
- "medium" + "soft": balanced, most versatile (most objects, places, general moods)
- "large" + "ultra-soft": atmospheric, ambient (skies, weather, calm emotions, time of day)

Don't default to large/ultra-soft. Match the intensity of the concept:
- "fire" → small-medium, sharp-soft (concentrated heat)
- "sunset" → large, ultra-soft (atmospheric)
- "neon" → small, sharp (focused glow)
- "ocean" → large, soft (expansive but with presence)
- "anxiety" → medium, sharp (tight, uncomfortable)
- "hope" → medium-large, soft (warm but not overwhelming)

Design principles:
- Beautiful gradients have CONTRAST—don't make everything muddy middle tones
- Position matters: light sources should feel natural (suns rise/set, glows emanate from logical places)
- When in doubt, go with "position": "center", "size": "medium", "softness": "soft"

Return ONLY valid JSON. No markdown, no explanation.`;
      }

      function parseLinearResponse(content) {
        const codeBlock = content.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlock) content = codeBlock[1].trim();
        let jsonMatch = content.match(/\[[\s\S]*\]/);
        if (!jsonMatch) {
          const trimmed = content.trim();
          if (trimmed.startsWith('[') && trimmed.endsWith(']')) jsonMatch = [trimmed];
        }
        if (!jsonMatch) throw new Error('No JSON array in response');
        let parsed;
        try {
          parsed = JSON.parse(jsonMatch[0]);
        } catch {
          throw new Error('Could not parse JSON');
        }
        const stops = normalizeStops(parsed);
        if (stops.length < 2) throw new Error('Need at least 2 color stops');
        return stops.sort((a, b) => a.stop - b.stop);
      }

      function parseRadialResponse(content) {
        const codeBlock = content.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlock) content = codeBlock[1].trim();
        let jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          const trimmed = content.trim();
          if (trimmed.startsWith('{') && trimmed.endsWith('}')) jsonMatch = [trimmed];
        }
        if (!jsonMatch) throw new Error('No JSON object in response');
        let obj;
        try {
          obj = JSON.parse(jsonMatch[0]);
        } catch {
          throw new Error('Could not parse JSON');
        }
        const centerColor = String(obj.centerColor || '').trim();
        const outerColor = String(obj.outerColor || '').trim();
        if (!centerColor || !outerColor) {
          throw new Error('Invalid radial response: missing centerColor/outerColor');
        }

        const normalizeColor = (c) => {
          let color = String(c || '').trim();
          if (!color.startsWith('#')) color = '#' + color;
          if (color.length === 4) {
            color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          return color.toUpperCase();
        };

        const softness = String(obj.softness || 'soft');
        const softnessStops = {
          'sharp': { center: 0, outer: 60 },
          'soft': { center: 0, outer: 85 },
          'ultra-soft': { center: 0, outer: 100 },
        };
        const { center: centerStop, outer: outerStop } = softnessStops[softness] || softnessStops['soft'];

        const stops = [];
        stops.push({ color: normalizeColor(centerColor), stop: centerStop });

        if (Array.isArray(obj.midColors)) {
          const mid = obj.midColors
            .map((m) => ({
              color: normalizeColor(m.color),
              position: Math.max(0, Math.min(100, Number(m.position) || 50)),
            }))
            .sort((a, b) => a.position - b.position);
          for (const m of mid) {
            const scaledPos = centerStop + (m.position / 100) * (outerStop - centerStop);
            stops.push({ color: m.color, stop: Math.round(scaledPos) });
          }
        }

        stops.push({ color: normalizeColor(outerColor), stop: outerStop });
        if (outerStop < 100) {
          stops.push({ color: normalizeColor(outerColor), stop: 100 });
        }

        return {
          stops: normalizeStops(stops).sort((a, b) => a.stop - b.stop),
          position: typeof obj.position === 'string' ? obj.position : 'center',
        };
      }

      async function generateGradient(prompt, type) {
        const systemPrompt = type === 'radial' ? radialSystemPrompt() : linearSystemPrompt();

        const res = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: MODEL,
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: `Generate a gradient for: ${prompt}` },
            ],
            stream: false,
          }),
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `Request failed (${res.status})`);
        }

        const data = await res.json();
        let content = data.message?.content || data.content || '';
        if (type === 'radial') return parseRadialResponse(content);
        return { stops: parseLinearResponse(content), position: 'center' };
      }

      function updateType() {
        currentType = typeSelect && typeSelect.value === 'radial' ? 'radial' : 'linear';
        if (lastStops && !isGenerating && !loadingFrameId) {
          preview.style.background = toCssGradient(lastStops, currentType);
        }
      }

      function setTypeDisabled(disabled) {
        if (typeSelect) {
          typeSelect.disabled = disabled;
          typeSelect.style.opacity = disabled ? '0.5' : '1';
        }
      }

      if (typeSelect) typeSelect.addEventListener('change', updateType);
      updateType();

      function applyGradientFromLast() {
        if (!lastStops) return;
        parent.postMessage(
          { pluginMessage: { type: 'apply-gradient', stops: lastStops, gradientType: currentType, radialPosition: lastRadialPosition } },
          '*'
        );
      }

      async function handleGenerate() {
        const q = promptEl.value.trim();
        if (!q) return;
        promptEl.blur();
        setStatus('');
        generateBtn.disabled = true;
        applyBtn.disabled = true;
        setTypeDisabled(true);
        isGenerating = true;
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        startLoadingAnimation();
        try {
          const result = await generateGradient(q, currentType);
          const previousStops = lastStops;
          lastStops = result.stops;
          hasGenerated = true;
          // Keep Figma behavior aligned with preview; ignore model position for now.
          lastRadialPosition = 'center';
          stopLoadingAnimation();
          animatePreviewTransition(previousStops, result.stops, currentType);
          applyBtn.disabled = !hasSelection;
        } catch (err) {
          stopLoadingAnimation();
          setStatus(String(err.message || err));
        } finally {
          generateBtn.disabled = false;
          setTypeDisabled(false);
          isGenerating = false;
          updateApplyVisibility();
        }
      }

      generateBtn.onclick = handleGenerate;
      promptEl.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') handleGenerate();
      });

      applyBtn.onclick = () => {
        if (!lastStops) return;
        promptEl.blur();
        applyGradientFromLast();
      };

      window.onmessage = (event) => {
        const msg = event.data && event.data.pluginMessage;
        if (!msg || msg.type !== 'selection-change') return;
        hasSelection = !!msg.hasSelection;
        applyBtn.disabled = !hasSelection || !lastStops || isGenerating;
        updateApplyVisibility();
      };

      promptEl.placeholder = 'Deep dark forest';
      preview.style.background = toCssGradient(DEFAULT_STOPS, currentType);
      updateApplyVisibility();
    </script>
  </body>
</html>
