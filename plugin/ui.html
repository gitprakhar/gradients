<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vibe Gradients</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/thomas-lowry/figma-plugin-ds/dist/figma-plugin-ds.css"
    />
    <style>
      :root { color-scheme: light; }
      body {
        margin: 0;
        background: #f6f6f7;
        overflow: hidden;
      }
      .wrap {
        display: flex;
        flex-direction: column;
        gap: 0;
        padding: 0 12px 12px;
        height: 100vh;
        overflow: hidden;
      }
      .tabs {
        position: sticky;
        top: 0;
        z-index: 2;
        display: flex;
        gap: 16px;
        background: #fff;
        padding: 8px 12px;
        margin: 0 -12px 12px -12px;
        border-bottom: 1px solid rgba(0,0,0,0.08);
      }
      .tab {
        padding: 6px 0;
        font-size: 12px;
        border: none;
        border-radius: 0;
        background: transparent;
        color: #666;
        cursor: pointer;
      }
      .tab.active {
        color: #111;
        font-weight: 600;
        border-bottom: 2px solid #111;
      }
      .panel {
        display: none;
        flex-direction: column;
        gap: 12px;
        padding-top: 0;
      }
      .panel.active {
        display: flex;
      }
      .preview {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 6px;
        background: linear-gradient(180deg, #e6e6e6, #cfcfcf);
        border: 1px solid rgba(0,0,0,0.06);
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .status {
        min-height: 18px;
        font-size: 12px;
        color: #666;
      }
      .hint {
        font-size: 11px;
        color: #999;
      }
      .button {
        border-radius: 4px;
      }
      .input__field {
        border-radius: 4px;
        padding: 6px 8px;
        border: 1px solid rgba(0,0,0,0.12);
        box-shadow: none;
      }
      .select-wrap {
        position: relative;
        width: 100%;
      }
      .select-wrap::after {
        content: '';
        position: absolute;
        right: 8px;
        top: 50%;
        width: 10px;
        height: 6px;
        transform: translateY(-50%);
        background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'><path d='M1 1.25L5 4.75L9 1.25' fill='none' stroke='%23979797' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/></svg>") no-repeat center / 10px 6px;
        pointer-events: none;
      }
      .select-wrap select.input__field {
        padding-right: 24px;
        appearance: none;
        -webkit-appearance: none;
        background: none;
      }
      .input__field {
        height: 32px;
        padding: 6px 8px;
        font-size: 12px;
        line-height: 1.2;
      }
      select.input__field {
        padding-right: 24px;
      }
      .button {
        height: 30px;
        padding: 0 10px;
        font-size: 12px;
        line-height: 30px;
      }
      .button--primary {
        background: #000;
        border-color: #000;
        color: #fff;
      }
      .button--primary:not(:disabled):hover {
        background: #111;
        border-color: #111;
      }
      #generate:not(:disabled):hover {
        background: #111;
        border-color: #111;
      }
      .button--secondary:not(:disabled):hover {
        background: rgba(0,0,0,0.04);
        border-color: rgba(0,0,0,0.12);
      }
      .button:focus {
        outline: none;
        box-shadow: none;
      }
      .button:focus-visible {
        outline: none;
        box-shadow: none;
      }
      .button:active {
        outline: none;
        box-shadow: none;
      }
      .button:disabled {
        border-color: transparent;
        box-shadow: none;
      }
      .library {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .library-empty {
        font-size: 12px;
        color: #777;
        padding: 6px 0;
      }
      .library-item {
        display: grid;
        grid-template-columns: 44px 1fr auto;
        gap: 8px;
        align-items: center;
        padding: 6px;
        border: 1px solid rgba(0,0,0,0.08);
        border-radius: 6px;
        background: #fff;
      }
      .library-preview {
        width: 44px;
        height: 44px;
        border-radius: 6px;
        border: 1px solid rgba(0,0,0,0.08);
        background: #eee;
      }
      .library-meta {
        display: flex;
        flex-direction: column;
        gap: 2px;
        min-width: 0;
      }
      .library-title {
        font-size: 12px;
        font-weight: 600;
        color: #111;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .library-subtitle {
        font-size: 11px;
        color: #666;
      }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="tabs">
        <button class="tab active" id="tab-generate" type="button">Generate</button>
        <button class="tab" id="tab-library" type="button">Library</button>
      </div>

      <div class="panel active" id="panel-generate">
        <div class="preview" id="preview"></div>
        <div class="input select-wrap">
          <select id="gradient-type" class="input__field" aria-label="Gradient type">
            <option value="linear" selected>Linear</option>
            <option value="radial">Radial</option>
          </select>
        </div>
        <div class="input">
          <input id="prompt" class="input__field" type="text" placeholder="Search a vibe…" />
        </div>
        <div class="row">
          <button id="generate" class="button button--primary" type="button">Generate</button>
          <button id="apply" class="button button--secondary" type="button" disabled>Apply</button>
          <span id="selection-hint" class="hint" style="display:none;">Select a layer to apply</span>
        </div>
        <div class="status" id="status"></div>
      </div>

      <div class="panel" id="panel-library">
        <div class="library" id="library-list"></div>
      </div>
    </div>

    <script>
      const API_URL = 'https://anycolorsyoulike.vercel.app/api/ollama/chat';
      const MODEL = 'gpt-oss:20b-cloud';

      const preview = document.getElementById('preview');
      const promptEl = document.getElementById('prompt');
      const generateBtn = document.getElementById('generate');
      const applyBtn = document.getElementById('apply');
      const statusEl = document.getElementById('status');
      const selectionHint = document.getElementById('selection-hint');
      const typeSelect = document.getElementById('gradient-type');
      const tabGenerate = document.getElementById('tab-generate');
      const tabLibrary = document.getElementById('tab-library');
      const panelGenerate = document.getElementById('panel-generate');
      const panelLibrary = document.getElementById('panel-library');
      const libraryList = document.getElementById('library-list');

      const DEFAULT_STOPS = [
        { color: '#0B1A0C', stop: 0 },
        { color: '#1B4B29', stop: 50 },
        { color: '#356B3A', stop: 100 },
      ];

      let lastStops = DEFAULT_STOPS;
      let lastRadialPosition = 'center';
      let currentType = 'linear';
      let lastPrompt = '';
      let cachePrompt = '';
      let cachedLinearStops = null;
      let cachedRadial = null;
      let savedGradients = [];
      let animationFrameId = null;
      let loadingFrameId = null;
      let isGenerating = false;
      let hasSelection = false;
      let hasGenerated = false;

      function setStatus(text) {
        statusEl.textContent = text || '';
      }

      function updateApplyVisibility() {
        if (!hasSelection) {
          applyBtn.style.display = 'none';
          selectionHint.style.display = hasGenerated && !isGenerating ? '' : 'none';
        } else {
          applyBtn.style.display = '';
          selectionHint.style.display = 'none';
          if (!isGenerating) setStatus('');
        }
      }

      function normalizeStops(raw) {
        if (!Array.isArray(raw)) return [];
        const stops = raw.map((s) => {
          let color = String(s.color || '').trim();
          if (!color.startsWith('#')) color = '#' + color;
          if (color.length === 4) {
            color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          const stop = Math.max(0, Math.min(100, Number(s.stop) || 0));
          return { color: color.toUpperCase(), stop: Math.round(stop) };
        });
        return stops.filter((s) => /^#[0-9A-F]{6}$/i.test(s.color));
      }

      function toCssGradient(stops, type) {
        const parts = stops.map((s) => `${s.color} ${s.stop}%`);
        if (type === 'radial') {
          return `radial-gradient(circle at center, ${parts.join(', ')})`;
        }
        return `linear-gradient(180deg, ${parts.join(', ')})`;
      }

      function setActiveTab(name) {
        const isGenerate = name === 'generate';
        tabGenerate.classList.toggle('active', isGenerate);
        tabLibrary.classList.toggle('active', !isGenerate);
        panelGenerate.classList.toggle('active', isGenerate);
        panelLibrary.classList.toggle('active', !isGenerate);
      }

      function formatDate(ts) {
        if (!ts) return '';
        try {
          return new Date(ts).toLocaleDateString();
        } catch {
          return '';
        }
      }

      function renderLibrary() {
        libraryList.innerHTML = '';
        if (!savedGradients.length) {
          const empty = document.createElement('div');
          empty.className = 'library-empty';
          empty.textContent = 'No gradients saved yet.';
          libraryList.appendChild(empty);
          return;
        }
        savedGradients.forEach((item) => {
          const row = document.createElement('div');
          row.className = 'library-item';

          const previewEl = document.createElement('div');
          previewEl.className = 'library-preview';
          previewEl.style.background = toCssGradient(item.stops || [], item.type || 'linear');

          const meta = document.createElement('div');
          meta.className = 'library-meta';
          const title = document.createElement('div');
          title.className = 'library-title';
          title.textContent = item.prompt || 'Untitled';
          const subtitle = document.createElement('div');
          subtitle.className = 'library-subtitle';
          subtitle.textContent = `${item.type || 'linear'} · ${formatDate(item.createdAt)}`;
          meta.appendChild(title);
          meta.appendChild(subtitle);

          const useBtn = document.createElement('button');
          useBtn.className = 'button button--secondary';
          useBtn.type = 'button';
          useBtn.textContent = 'Use';
          useBtn.addEventListener('click', () => {
            applySavedGradient(item);
          });

          row.appendChild(previewEl);
          row.appendChild(meta);
          row.appendChild(useBtn);
          libraryList.appendChild(row);
        });
      }

      function applySavedGradient(item) {
        if (!item || !Array.isArray(item.stops) || item.stops.length < 2) return;
        const previousStops = lastStops;
        currentType = item.type === 'radial' ? 'radial' : 'linear';
        typeSelect.value = currentType;
        lastStops = item.stops;
        lastRadialPosition = item.radialPosition || 'center';
        lastPrompt = item.prompt || '';
        promptEl.value = lastPrompt;
        cachePrompt = lastPrompt;
        cachedLinearStops = currentType === 'linear' ? item.stops : null;
        cachedRadial = currentType === 'radial' ? { stops: item.stops, position: lastRadialPosition } : null;
        hasGenerated = true;
        animatePreviewTransition(previousStops, lastStops, currentType);
        applyBtn.disabled = !hasSelection;
        updateApplyVisibility();
        setActiveTab('generate');
      }

      // --- Color interpolation for preview animation ---
      function hexToRgb(hex) {
        const n = parseInt(hex.slice(1), 16);
        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
      }
      function rgbToHex(r, g, b) {
        return '#' + [r, g, b].map((x) => Math.round(x).toString(16).padStart(2, '0')).join('');
      }
      function lerpHex(a, b, t) {
        const ra = hexToRgb(a), rb = hexToRgb(b);
        return rgbToHex(
          ra.r + (rb.r - ra.r) * t,
          ra.g + (rb.g - ra.g) * t,
          ra.b + (rb.b - ra.b) * t
        );
      }
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }
      function sampleGradient(stops, p) {
        const sorted = [...stops].sort((a, b) => a.stop - b.stop);
        if (p <= 0) return sorted[0].color;
        if (p >= 1) return sorted[sorted.length - 1].color;
        const pos = p * 100;
        for (let i = 0; i < sorted.length - 1; i++) {
          if (pos >= sorted[i].stop && pos <= sorted[i + 1].stop) {
            const d = sorted[i + 1].stop - sorted[i].stop;
            const t = d === 0 ? 1 : (pos - sorted[i].stop) / d;
            return lerpHex(sorted[i].color, sorted[i + 1].color, t);
          }
        }
        return sorted[0].color;
      }
      function animatePreviewTransition(fromStops, toStops, type) {
        if (!fromStops || fromStops.length < 2) {
          preview.style.background = toCssGradient(toStops, type);
          return;
        }
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        const positions = Array.from(
          new Set([...fromStops.map((s) => s.stop), ...toStops.map((s) => s.stop), 0, 100])
        ).sort((a, b) => a - b);

        const startColors = positions.map((p) => sampleGradient(fromStops, p / 100));
        const endColors = positions.map((p) => sampleGradient(toStops, p / 100));
        const duration = 900;
        const state = { start: 0 };

        const tick = (now) => {
          if (!state.start) state.start = now;
          const elapsed = now - state.start;
          const t = Math.min(1, elapsed / duration);
          const eased = easeInOutCubic(t);
          const interpolated = positions.map((p, i) => ({
            stop: p,
            color: lerpHex(startColors[i], endColors[i], eased),
          }));
          preview.style.background = toCssGradient(interpolated, type);
          if (t < 1) {
            animationFrameId = requestAnimationFrame(tick);
          } else {
            animationFrameId = null;
            preview.style.background = toCssGradient(toStops, type);
          }
        };
        animationFrameId = requestAnimationFrame(tick);
      }

      function startLoadingAnimation() {
        if (loadingFrameId) cancelAnimationFrame(loadingFrameId);
        const baseStops = lastStops && lastStops.length >= 2
          ? lastStops
          : [{ color: '#f0f0f0', stop: 0 }, { color: '#e2e2e2', stop: 100 }];
        const positions = Array.from(
          new Set([...baseStops.map((s) => s.stop), 0, 100])
        ).sort((a, b) => a - b);

        const state = { start: 0 };
        const tick = (now) => {
          if (!state.start) state.start = now;
          const elapsed = now - state.start;
          const phase = (elapsed / 1000) * 45;
          const stops = positions.map((p) => {
            const hue = (p * 2 + phase) % 360;
            return { stop: p, color: `hsl(${hue} 80% 65%)` };
          });
          preview.style.background = toCssGradient(stops, currentType);
          loadingFrameId = requestAnimationFrame(tick);
        };
        loadingFrameId = requestAnimationFrame(tick);
      }

      function stopLoadingAnimation() {
        if (loadingFrameId) {
          cancelAnimationFrame(loadingFrameId);
          loadingFrameId = null;
        }
      }

      function linearSystemPrompt() {
        return `You generate beautiful linear gradients that capture the essence, mood, and color palette of ANY concept.

A linear gradient flows from top to bottom, like light falling, atmosphere shifting, or energy moving. Your job is to translate ANY input into a visually stunning gradient.

Output format:
[{"color": "#RRGGBB", "stop": 0}, {"color": "#RRGGBB", "stop": 100}]

Rules:
- Generate 2-4 color stops
- "stop" is position: 0 = top, 100 = bottom
- First stop must be 0, last must be 100
- Middle stops (e.g., 30, 60) create richer transitions

Interpretation guide:

EMOTIONS → Translate feeling into color flow
- Warm emotions (love, happy, hope) → warm colors flowing down, light to rich
- Dark emotions (hate, anxiety, drowning) → heavy darks at top or bottom, saturated tones
- Calm emotions → muted tones, gentle transitions, no harsh jumps

PLACES → Capture the iconic color palette and atmosphere
- Cities → their vibe (Mumbai = golden sun over ocean blue, LA = pink haze to deep purple)
- Nature locations → sky-to-ground logic (mountains = pale sky to deep forest, desert = hot white to sand orange)
- Countries → flag colors OR iconic landscape colors

NATURE/WEATHER → Think like a sky or landscape
- Time of day → sunrise/sunset warm at bottom rising to cool; night dark throughout
- Weather → storms are heavy grays/blues; snow is soft whites with cool blue shadows
- Seasons → summer is bright and warm; winter is cool and muted

OBJECTS → Extract the essential color palette
- Focus on 2-3 most recognizable colors
- Arrange them in a way that feels natural (e.g., apple = deep red to bright red to green stem hint)

AESTHETICS/VIBES → Match the era or style
- "90s" → neon cyan, magenta, high contrast stops
- "cottage core" → cream, dusty pink, sage green
- "cyber" → dark base, neon accent, teal/magenta pops
- "vaporwave" → pink, cyan, purple with distinct bands

COLORS → Create depth, not flat swatches
- "blue" → give it range (sky blue to deep navy, or navy to electric)
- Single-color requests should still have 2-3 shades for richness

ABSTRACT/POETIC → Interpret the imagery
- "jasmine in rain" → soft white to pale green to misty gray-blue
- "drowning fade" → light surface blue to deep dark ocean at bottom

NONSENSE/GREETINGS → Default to something friendly
- Warm, approachable colors
- Gentle transitions
- Nothing extreme

Design principles:
- Beautiful gradients have CONTRAST—avoid muddy middle tones
- Think about gravity: light rises, darkness pools, heat radiates
- Smooth transitions need space—don't cluster stops at 30, 35, 40
- When in doubt: 3 stops at 0, 40-50, 100

Return ONLY valid JSON array. No markdown, no explanation.
Format: [{"color":"#RRGGBB","stop":number}, ...]`;
      }

      function radialSystemPrompt() {
        return `You generate beautiful radial gradients that capture the essence, mood, and color palette of ANY concept.

A radial gradient is a glow emanating from a focal point—like light, energy, or atmosphere. Your job is to translate ANY input into a visually stunning gradient.

Output format:
{
  "centerColor": "#RRGGBB",      // focal point color
  "outerColor": "#RRGGBB",       // edge/background color
  "midColors": [{"color": "#RRGGBB", "position": 20-80}],  // optional, for richer gradients
  "position": "center" | "top-center" | "bottom-center" | "top-left" | "top-right" | "bottom-left" | "bottom-right",
  "size": "small" | "medium" | "large",
  "softness": "sharp" | "soft" | "ultra-soft",
  "shape": "circle" | "ellipse"
}

Interpretation guide:

EMOTIONS → Translate feeling into color temperature, intensity, and softness
- Warm emotions (love, happy, hope) → warm colors, soft edges, centered or rising
- Dark emotions (hate, anxiety, drowning) → deep/saturated colors, can be sharp, darker edges
- Calm emotions → muted tones, ultra-soft, gentle transitions

PLACES → Capture the iconic color palette and atmosphere, not literal geography
- Cities → their vibe (Mumbai = vibrant yellows + ocean blues, Dubai = gold + deep blue night)
- Nature locations → dominant landscape colors (Yosemite = forest green + granite gray + sky)
- Countries → can reference flag colors OR iconic landscapes

NATURE/WEATHER → Atmospheric interpretation
- Time of day → position the "light source" appropriately (sunset = bottom, morning = top-right)
- Weather → snow is soft whites, storms are dark and sharp
- Elements → fire rises (bottom-center), water pools (center or bottom)

OBJECTS → Extract the essential color palette
- Focus on 2-3 most recognizable colors
- Consider the object's texture (soft blanket = soft gradient, sharp pencil = defined stops)

AESTHETICS/VIBES → Match the era or style's color language
- "90s" → neon, cyan, magenta, high contrast
- "cottage core" → muted greens, dusty pinks, cream
- "cyber" → dark bases, neon accents, teals and magentas

COLORS → Create depth and richness, not flat swatches
- "blue" shouldn't be just blue—give it depth (deep navy center fading to bright cyan, or vice versa)
- Add subtle variations to make single-color requests interesting

ABSTRACT/POETIC → Interpret the imagery and mood
- "jasmine in rain" → soft whites, pale greens, gray-blue mist
- "drowning fade" → deep ocean blues, darkness pulling down

NONSENSE/GREETINGS → Default to something friendly and universally appealing
- Warm, approachable colors
- Soft gradients
- Nothing too extreme

QUESTIONS → Answer visually
- "What does X look like" → your best interpretation of X's color essence

Size and softness guidelines:
- "small" + "sharp": intense, focused energy (neon signs, spotlights, concentrated emotions like anxiety)
- "medium" + "soft": balanced, most versatile (most objects, places, general moods)
- "large" + "ultra-soft": atmospheric, ambient (skies, weather, calm emotions, time of day)

Don't default to large/ultra-soft. Match the intensity of the concept:
- "fire" → small-medium, sharp-soft (concentrated heat)
- "sunset" → large, ultra-soft (atmospheric)
- "neon" → small, sharp (focused glow)
- "ocean" → large, soft (expansive but with presence)
- "anxiety" → medium, sharp (tight, uncomfortable)
- "hope" → medium-large, soft (warm but not overwhelming)

Design principles:
- Beautiful gradients have CONTRAST—don't make everything muddy middle tones
- Position matters: light sources should feel natural (suns rise/set, glows emanate from logical places)
- When in doubt, go with "position": "center", "size": "medium", "softness": "soft"

Return ONLY valid JSON. No markdown, no explanation.`;
      }

      function parseLinearResponse(content) {
        const codeBlock = content.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlock) content = codeBlock[1].trim();
        let jsonMatch = content.match(/\[[\s\S]*\]/);
        if (!jsonMatch) {
          const trimmed = content.trim();
          if (trimmed.startsWith('[') && trimmed.endsWith(']')) jsonMatch = [trimmed];
        }
        if (!jsonMatch) throw new Error('No JSON array in response');
        let parsed;
        try {
          parsed = JSON.parse(jsonMatch[0]);
        } catch {
          throw new Error('Could not parse JSON');
        }
        const stops = normalizeStops(parsed);
        if (stops.length < 2) throw new Error('Need at least 2 color stops');
        return stops.sort((a, b) => a.stop - b.stop);
      }

      function parseRadialResponse(content) {
        const codeBlock = content.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlock) content = codeBlock[1].trim();
        let jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          const trimmed = content.trim();
          if (trimmed.startsWith('{') && trimmed.endsWith('}')) jsonMatch = [trimmed];
        }
        if (!jsonMatch) throw new Error('No JSON object in response');
        let obj;
        try {
          obj = JSON.parse(jsonMatch[0]);
        } catch {
          throw new Error('Could not parse JSON');
        }
        const centerColor = String(obj.centerColor || '').trim();
        const outerColor = String(obj.outerColor || '').trim();
        if (!centerColor || !outerColor) {
          throw new Error('Invalid radial response: missing centerColor/outerColor');
        }

        const normalizeColor = (c) => {
          let color = String(c || '').trim();
          if (!color.startsWith('#')) color = '#' + color;
          if (color.length === 4) {
            color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          return color.toUpperCase();
        };

        const softness = String(obj.softness || 'soft');
        const softnessStops = {
          'sharp': { center: 0, outer: 60 },
          'soft': { center: 0, outer: 85 },
          'ultra-soft': { center: 0, outer: 100 },
        };
        const { center: centerStop, outer: outerStop } = softnessStops[softness] || softnessStops['soft'];

        const stops = [];
        stops.push({ color: normalizeColor(centerColor), stop: centerStop });

        if (Array.isArray(obj.midColors)) {
          const mid = obj.midColors
            .map((m) => ({
              color: normalizeColor(m.color),
              position: Math.max(0, Math.min(100, Number(m.position) || 50)),
            }))
            .sort((a, b) => a.position - b.position);
          for (const m of mid) {
            const scaledPos = centerStop + (m.position / 100) * (outerStop - centerStop);
            stops.push({ color: m.color, stop: Math.round(scaledPos) });
          }
        }

        stops.push({ color: normalizeColor(outerColor), stop: outerStop });
        if (outerStop < 100) {
          stops.push({ color: normalizeColor(outerColor), stop: 100 });
        }

        return {
          stops: normalizeStops(stops).sort((a, b) => a.stop - b.stop),
          position: typeof obj.position === 'string' ? obj.position : 'center',
        };
      }

      async function generateGradient(prompt, type) {
        const systemPrompt = type === 'radial' ? radialSystemPrompt() : linearSystemPrompt();
        const userPrompt = type === 'radial'
          ? `Generate a radial gradient for: ${prompt}`
          : `Generate a gradient for: ${prompt}`;

        const res = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: MODEL,
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userPrompt },
            ],
            stream: false,
          }),
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `Request failed (${res.status})`);
        }

        const data = await res.json();
        let content = data.message?.content || data.content || '';
        if (type === 'radial') return parseRadialResponse(content);
        return { stops: parseLinearResponse(content), position: 'center' };
      }

      function updateType(shouldGenerate) {
        currentType = typeSelect && typeSelect.value === 'radial' ? 'radial' : 'linear';
        const prompt = getEffectivePrompt();
        const hasUserPrompt = !!(promptEl.value.trim() || lastPrompt);
        const hasCached = cachePrompt === prompt && (
          (currentType === 'linear' && Array.isArray(cachedLinearStops)) ||
          (currentType === 'radial' && cachedRadial && Array.isArray(cachedRadial.stops))
        );

        if (shouldGenerate && !isGenerating && hasUserPrompt && prompt && hasCached) {
          applyCachedForType(prompt);
          return;
        }

        if (lastStops && !isGenerating && !loadingFrameId) {
          preview.style.background = toCssGradient(lastStops, currentType);
        }
      }

      function setTypeDisabled(disabled) {
        if (typeSelect) {
          typeSelect.disabled = disabled;
          typeSelect.style.opacity = disabled ? '0.5' : '1';
        }
      }

      if (typeSelect) typeSelect.addEventListener('change', () => updateType(true));
      updateType(false);

      function applyGradientFromLast() {
        if (!lastStops) return;
        parent.postMessage(
          { pluginMessage: { type: 'apply-gradient', stops: lastStops, gradientType: currentType, radialPosition: lastRadialPosition } },
          '*'
        );
      }

      function getEffectivePrompt() {
        const q = promptEl.value.trim();
        if (q) return q;
        if (lastPrompt) return lastPrompt;
        return (promptEl.placeholder || '').trim();
      }

      function applyCachedForType(prompt) {
        if (cachePrompt !== prompt) return;
        const previousStops = lastStops;
        if (currentType === 'radial' && cachedRadial && Array.isArray(cachedRadial.stops)) {
          lastStops = cachedRadial.stops;
          lastRadialPosition = cachedRadial.position || 'center';
        } else if (currentType === 'linear' && Array.isArray(cachedLinearStops)) {
          lastStops = cachedLinearStops;
        } else {
          return;
        }
        hasGenerated = true;
        animatePreviewTransition(previousStops, lastStops, currentType);
        applyBtn.disabled = !hasSelection;
        updateApplyVisibility();
      }

      async function handleGenerate(forcedPrompt) {
        const explicitPrompt = typeof forcedPrompt === 'string' ? forcedPrompt : '';
        const q = String(explicitPrompt || getEffectivePrompt() || '').trim();
        if (!q) return;
        if (cachePrompt && cachePrompt !== q) {
          cachedLinearStops = null;
          cachedRadial = null;
        }
        cachePrompt = q;
        lastPrompt = q;
        promptEl.blur();
        setStatus('');
        generateBtn.disabled = true;
        applyBtn.disabled = true;
        setTypeDisabled(true);
        isGenerating = true;
        updateApplyVisibility();
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        startLoadingAnimation();
        try {
          const result = await generateGradient(q, currentType);
          const previousStops = lastStops;
          lastStops = result.stops;
          hasGenerated = true;
          // Keep Figma behavior aligned with preview; ignore model position for now.
          lastRadialPosition = 'center';
          if (currentType === 'radial') {
            cachedRadial = { stops: result.stops, position: result.position || 'center' };
          } else {
            cachedLinearStops = result.stops;
          }
          parent.postMessage(
            {
              pluginMessage: {
                type: 'save-gradient',
                gradient: {
                  id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                  createdAt: Date.now(),
                  prompt: q,
                  type: currentType,
                  stops: result.stops,
                  radialPosition: lastRadialPosition,
                },
              },
            },
            '*'
          );
          stopLoadingAnimation();
          animatePreviewTransition(previousStops, result.stops, currentType);
          applyBtn.disabled = !hasSelection;
        } catch (err) {
          stopLoadingAnimation();
          setStatus(String(err.message || err));
        } finally {
          generateBtn.disabled = false;
          setTypeDisabled(false);
          isGenerating = false;
          updateApplyVisibility();
        }
      }

      generateBtn.onclick = handleGenerate;
      // Only generate on explicit button click.

      applyBtn.onclick = () => {
        if (!lastStops) return;
        promptEl.blur();
        applyGradientFromLast();
      };

      window.onmessage = (event) => {
        const msg = event.data && event.data.pluginMessage;
        if (!msg || !msg.type) return;
        if (msg.type === 'selection-change') {
          hasSelection = !!msg.hasSelection;
          applyBtn.disabled = !hasSelection || !lastStops || isGenerating;
          updateApplyVisibility();
          return;
        }
        if (msg.type === 'saved-gradients') {
          savedGradients = Array.isArray(msg.gradients) ? msg.gradients : [];
          renderLibrary();
        }
      };

      tabGenerate.addEventListener('click', () => setActiveTab('generate'));
      tabLibrary.addEventListener('click', () => setActiveTab('library'));

      promptEl.placeholder = 'Deep dark forest';
      preview.style.background = toCssGradient(DEFAULT_STOPS, currentType);
      updateApplyVisibility();
      parent.postMessage({ pluginMessage: { type: 'load-gradients' } }, '*');
    </script>
  </body>
</html>
